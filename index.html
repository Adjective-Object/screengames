<!DOCTYPE html>
<html>
<head>
<title></title>
<style>
body, html {
    width: 100%;
    height: 100%;
}

*, *:before, *:after {
    padding:0;
    margin: 0;
}

.game-container {
    height: 100%;
    width: 100%;
    background-color: #EEEEEE;
    display: flex;
    align-items: center;
    justify-content: center;
}

.drawing-canvas {
    background-color: white;
}

</style>
</head>
<body>
<section id="game-container" class="game-container">
    <svg id="draw-target" class="drawing-canvas" width="400" height="400" viewbox="0 0 400 400"></svg>
</section>
<script type="text/javascript">

function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
    s4() + '-' + s4() + s4() + s4();
}

function dist(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

/*
interface Point {
    x: float,
    y: float,
}

interface Stroke {
    points: Point[],

}

interface Drawing {
    strokes: {
        [key: string]: Stroke
    }
    strokeOrder: [string];
}
*/

class Drawing {
    constructor(props) {
        // Config
        this.distanceThreshold = 10;
        this.timeDistanceThreshold = 2;
        this.timeDifferenceThreshold = 400;

        // Long-lived state
        this.strokes = {};
        this.strokeOrder = [];

        // State for tracking the current stroke
        this.currentStrokeID = null;
        this.lastSampleTime = null;
        this.pendingSample = null;
    }

    startNewStroke(point, time) {
        // TODO color ?
        this.currentStrokeID = guid();
        this.strokeOrder.push(this.currentStrokeID);
        this.strokes[this.currentStrokeID] = {
            points: [point]
        };
        this.pendingSample = point;
        this.lastSampleTime = time;
    }

    sampleMovement(point, time) {
        // Bail if not in the middle of recording a new stroke
        if(this.currentStrokeID === null) {
            return;
        }

        let last_point = this.getLastPointOfStroke(this.currentStrokeID);
        let distance = dist(point, last_point);
        let timeDifference = time - this.lastSampleTime;
        if (distance > this.distanceThreshold) {
            this.__addPointToCurrentStroke(point, time);
        } else if (
            timeDifference > this.timeDifferenceThreshold &&
            distance > this.timeDistanceThreshold) {
            this.__addPointToCurrentStroke(point, time);
        }
        this.pendingSample = point;
    }

    finishCurrentStroke(point, time) {
        // Bail if not in the middle of recording a new stroke
        if(this.currentStrokeID === null) {
            return;
        }

        this.__addPointToCurrentStroke(this.pendingSample, time);
        this.currentStrokeID = null;
        this.pendingSample = null;
    }

    __addPointToCurrentStroke(point, time) {
        this.strokes[this.currentStrokeID].points.push(point);
        this.lastSampleTime = time;
    }

    getLastPointOfStroke(stroke_id) {
        let points = this.strokes[stroke_id].points;
        return points[points.length - 1];
    }
}

class DrawingRenderer {
    renderDrawingToSVG(drawing, svg) {
        svg.innerHTML = '';
        for (let strokeID of drawing.strokeOrder) {
            // Insert a new line as the last child of the svg
            svg.appendChild(this.__renderBaseStroke(
                drawing.strokes[strokeID]
            ));

            if (strokeID == drawing.currentStrokeID) {
                svg.appendChild(this.__renderPendingLine(
                    drawing.strokes[strokeID],
                    drawing.pendingSample
                ))
            }
        }
    }

    __renderBaseStroke(stroke) {
        if (this.__strokeIsDot(stroke)) {
            let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', stroke.points[0].x);
            circle.setAttribute('cy', stroke.points[0].y);
            circle.setAttribute('r', 1.5);
            circle.setAttribute('style', 'fill:black; stroke:black; stroke-width:0');
            return circle;
        }

        let points = stroke.points.map(({x, y}) => x + ',' + y);
        let points_string = points.join(' ');
        let polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points_string);
        polyline.setAttribute('style', 'fill:none; stroke:black; stroke-width:3');
        return polyline
    }

    __renderPendingLine(stroke, pending_sample) {
        let last_point = stroke.points[stroke.points.length - 1];
        let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', last_point.x)
        line.setAttribute('y1', last_point.y);
        line.setAttribute('x2', pending_sample.x);
        line.setAttribute('y2', pending_sample.y);
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('style', 'fill:none; stroke:red; stroke-width:3');
        return line;
    }

    // Determine if a stroke is just a single dot
    __strokeIsDot(stroke) {
        return stroke.points.length == 2 &&
            stroke.points[0].x == stroke.points[1].x &&
            stroke.points[0].y == stroke.points[1].y;
    }

}

const SVG_DIM = 400;
let drawing = new Drawing();
let renderer = new DrawingRenderer();
let drawTarget = document.getElementById('draw-target');
let renderTarget = drawTarget;

function transformToCanvasSpace(mouse_event) {
    let boundingRect = drawTarget.getBoundingClientRect();
    // Get location of the mouse event in SVG space
    console.log(drawTarget.viewBox)
    console.log((mouse_event.clientX - boundingRect.left) /
        boundingRect.width);
    viewbox_x =
        (mouse_event.clientX - boundingRect.left) /
        boundingRect.width *
        drawTarget.viewBox.baseVal.width +
        drawTarget.viewBox.baseVal.x;
    viewbox_y =
        (mouse_event.clientY - boundingRect.top) /
        boundingRect.height *
        drawTarget.viewBox.baseVal.height +
        drawTarget.viewBox.baseVal.y;
    return {
        x: viewbox_x,
        y: viewbox_y,
    };
}

function handleMouseDown (mouse_down_event) {
    drawing.startNewStroke(
        transformToCanvasSpace(mouse_down_event),
        (new Date()).getTime(),
    );
    renderer.renderDrawingToSVG(drawing, renderTarget);
}

function handleMouseMove(mouse_move_event) {
    drawing.sampleMovement(
        transformToCanvasSpace(mouse_move_event),
        (new Date()).getTime(),
    );
    renderer.renderDrawingToSVG(drawing, renderTarget);
}

function handleMouseUp(mouse_up_event) {
    drawing.finishCurrentStroke(
        transformToCanvasSpace(mouse_up_event),
        (new Date()).getTime(),
    );
    renderer.renderDrawingToSVG(drawing, renderTarget);
}

drawTarget.addEventListener('mousedown', handleMouseDown);
drawTarget.addEventListener('mousemove', handleMouseMove);
drawTarget.addEventListener('mouseup', handleMouseUp);
drawTarget.addEventListener('touchstart', (e) => {
    handleMouseDown(e.changedTouches[0])
    // Prevent double-tap-to-zoom
    e.preventDefault();
});
drawTarget.addEventListener('touchmove', (e) => {
    handleMouseMove(e.changedTouches[0])
    // Prevent pinch zooming
    e.preventDefault();
});
drawTarget.addEventListener('touchend', (e) => {
    handleMouseUp(e.changedTouches[0])
});

</script>
</body>
</html>
